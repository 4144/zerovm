in the current version:
-------------------------------------------------------------
ZMQ PROBLEMS
============
- fix the bug with the lost messages
  zerovm hangs up with messages:
  - channel has lost messages
  - channel wasn't closed
- how to block on zmq_send()?
  - there is a possibility to use freeing function as callback and longjmp. (awfull)
  - use rep/req instead of push/pull
+ how not to block on zmq_term()? if there were non blocking zmq_sends
  + manually close all channels (waiting when all messages are sent)  

CHANNELS DESIGN
===============
+ when the local file opened for write from more then 1 zerovm
  file will have a mess in data
  + solution mention it in the documentation and proxy must not allow to pass
  to manifests such collisions
  (see synchronized channels). just in case, check the document if i wrote everything right

+ fix issue with send zero-copy buffer reuse. if is not possible to block on send
  remove zero-copy to prevent overwriting the data from the buffer before its real
  sending. there are 3 possible fixes:
  - always block on send (due nexe runtime)
  - "mprotect" buffer to read-only access and mention it in the channels document
  - "block on next" if it is impossible to block on 1 message. send empty (or some special)
    message and block on it (after unblock we know that the real message (1st one) has been sent )
    for the long multipart message it is not so cumbersome
  + an extra copy to an extra buffer

+ fix issue with zmq_term(). it blocks even if there ar no outgoing messages
  perhaps the problem lies in the finalization order: PUSH channels should be closed 1st.
  can be solved with bugfix or 
  + with proper order in manifest ("push" channels should be 1st)
+ add name service
  + prepare 2 structures to hold "bind" and "connect" channels list
  + make hash function to hash channels names to 32-bit values
  + make (de)serializers to receive/send channels list
- split prefetch.* into prefetch and name service. name service should have a very simple api:
  - init / dispose
  - the 2nd pass to connect channels. used from mount_channels.c: KickNetworkChannels()
  - give_url() / get_url()
? add read and write offsets to channel definition in manifest (9 fields?)
+ ensure that network eof is working
+ write complete test to test network channels (over tcp protocol)
+ fix bug in struct ZVMChannel
+ fix bug in cdr
+ fix crash: "malloc(): smallbin double linked list corrupted"
+ fix cdr special case: initialize putpos with file size or (even better) add new fields 
  to channel description (read offset and write offset)
+ zvm_pread/zvm_pwrite must return -1 on error and set eerno to correct standard error code
  http://publib.boulder.ibm.com/infocenter/zos/v1r12/index.jsp?topic=%2Fcom.ibm.zos.r12.bpxbd00%2Fpread.htm
+ make EOF. for example pass it as 0 read bytes and -1 current position
+ add network channels to the file abstraction
+ all NETWORKING "todo" comments and NETWORKING conditional compilation must be removed
+ replace 2nd channel attribute "id" with "alias".
+ write more strict channels dealocation: free all allocated memory, free nacl descriptor e.t.c
+ zerovm special channel names (resides in "/dev/"): stdin, stdout, stderr, input, output, debug
+ design debug channel. zrt library can use it for the debugging purposes

MANIFEST
========
+ add a new keyword "NodeName" and pass it as argv[0]
+ make "NodeName" containg 2 parts: user specified string, and id (number) assigned by the proxy
+ add a new "Environment" keyword
+ add a new "Report" keyword. remove the old one. 
  this task needs constant report and log ready
  update: completely removed. substituted with stdout print

OTHER
=====
- fix broken tests
  +- manifest parser: passes. needs update
  - manifest setup: compiles. doesn't pass
  - sel_ldr: compiles. doesn't pass, needs minor fixes

- add new unit tests
  - channels: mount channels, preload, prefetch, nameservice (how to test network channels?)
  - trap

+ add extended signals handling to zerovm. zerovm must survive any nexe error.
	+ care about zerovm report
	+ care about channels
	update. the most likely zerovm will survive own errors and generate report

+ constant zerovm log.
  + remove log setup from manifest
  + generate log name using define from compiler -D and pid
    update: syslog used
  + create log asap (all zerovm messages goes there)
  + remove all printf, fprintf, perror e.t.c occurences
  
+ constant zerovm report. stdout used. contains 3 fields:
  nexe retcode. zerovm retcode. state (ok, timeout, signal)


in the next version:
-------------------------------------------------------------
- choose a proper switcher when switch to untrusted 1st time
+ update validator
+ extract validator from the zervm code. zerovm will use standalone validator
+ remove dfa validator support. disabled to better times
- add cpu features detection to sort (or even better - to zrt)
- update /readme (use "force" to make the user download nacl sdk zerovm currently uses) 

- add more logs
+ replace COND_ABORT() macro to something more finished and strict:
  any fail cases which must terminate nacl should be logged to nacl log
  any "impossible fail" must be checked by assert() (main purpose: prevent 
  improper zerovm code changes/usage) any non fatal cases must use something else (not "ABORT")
- move trap.c to service_runtime/. even better to move the code inside *syscall*.* and remove
  trap.* files
- put all invocations of manifest initializations to nacl init modules
  - or remove the init modules and do it from main()
- move all error messages and codes to nacl_error_code.* (especially from sel_main.c and manifest/)
  note: except fatal errors
  WARNING: get familiar with UMA first. perhaps it is not so good to update its error codes
+ make one extra trap() function - set_syscallback(). because using trap() setup for it
  has potentially problem and yet look ugly.
  update: rework trap() api
- gather and classify all internal error codes to one enumeration
  perhaps it would be a good idea to include "src/service_runtime/include/sys/errno.h"
  (and other headers with error/return codes)
+ make timeout engine instead of useless ResumeCpuClock() and PauseCpuClock()
	update: ResumeCpuClock() and PauseCpuClock() removed
? i need to decide what nacl syscalls will be counted against max_syscall:
  1. all
  2. existing only
  3. trap()
  4. only those who translated to the real system calls -- GOOD CANDIDATE
  5. none


completed releases:
-------------------------------------------------------------
+ remove not nessessary switches from zerovm command line
  only manifest, debug and validator switches must remain
+ completely remove nacl random  
+ "blob" completely removed from the zerovm code
+ check NaCl_page_alloc_randomized() and nap->dispatch_thunk.
  if it is really randomized and user can read it, it should be
  changed. user must not get random values bypassing manifest
  +update: fix thunk. it should be constant. remove randomization


problems to solve in the future versions:
-------------------------------------------------------------
- make user etag calculation: md5 of allocated user memory, user available system space
  1. 64k..end of setbrk position 
  2. channels buffers if allocated
  3. stack
  (1) and (2) can be get from the memory manager
- show the help on empty or invalid command line.
  it is broken now
- revise nacllog defines (LOG_ERROR, LOG_FATAL, LOG_INFO ..)
  - debug level for manifest validation should be added
  - full debug level
  of course to make it working a lot of functions should be equipped with input parameters logging
+ find the way how to exchange variable length arrays between trusted and untrusted code 
  just use "push-pull". ugly but simple and safe (of course if made via zvm api)
- there is snprintf usage in signal handler. is it safe?
- replace (if possible) lonjump with naclexit(). looks doable. problems are:
  - perf_counters
  - syslog finilizer (perhaps can be skipped)

- timeout. 1. problem to intercept sigxcpu 2. sigxcpu doesn't occure when sleep or i/o
  perhaps this is linked to (1)
- cpu accounting
- use setrlimit() to limit resources usage (according to given manifest)
+ finish with api error codes
  standard errno has been used
  - remove "zvm_errors.h"
+ bug in environment: Environment = TimeStamp, 1337012520, Gort, klaato_barada_nikto
  gives "klaato_barada_niktoQ". fixed
  
global plan
-------------------------------------------------------------
19. read "man 2 flock" and try to make local channel locked
+1. remove validator and clean up all project removing needless parts
   -+ remove imc
   + remove (almost all) desc
   - remove reference counter?
   - remove log
   -+ remove gio (or replace with very tiny version)
   - remove platform
   - remove platform_qualify
+2. add name service for the network channels
15. get rid of the needless platform describing folders: linux, x86, posix e.t.c.
16. some headers can be joined or even eliminated. same for particular .c files
17. include/ from zvm root should be distributed between src/ folder
3. redesign project structure
   api/
   doc
   src/
     - channels (all about channels)
     - loader (elf loader, user space, e.t.c.)
     - main (main, gio and scrapyard)
     - manifest (parser, setup, zvm config)
     - security (signals, platform qualifier, fault injection e.t.c.)
     - syscalls (nacl syscalls, trap, memory manager, trampoline)
     - tests (functional, unit, security tests and samples)
   thirdparty/
4. cover all source code with tests: unit, functional and security tests
5. rewrite project makefile. make it small, clean and clear
   add building options: debug, release (default), tests
6. add random read random write channels
7. redesign logging, remove nacl log code
8. allocate all zerovm memory in start of zerovm and remove "NULL checks"
9. zerovm error codes and states
10. zerovm setup: move all settings (defines, constants e.t.c.) to separate header
+- 11. reorganize and update the project documentation (and the source code comments)
12. add "snapshot" engine: memory dump and registers dump (using nacl nanosleep syscall)
13. write "blob" (the untrusted code loading before nexe start) 
!14. revive etag: md5 of user space. make an extended version with the output channels data
18. check the memory availability when untrusted code provides area to read/write
    it will allow get rid of signal SIGSEGV
19. add channel size? now it is coupled with pustsize (getsize) limit
997. write as much zerovm api examples as possible
998. the ultimate project source code refactoring
999. replace all third party code (so far it is zeromq) to prevent leaks, security holes and misbehaviour

