CHANNELS DESIGN
===============
manifest: name / ipc
manifest: access type: sequantal / random
manifest: offset (?) (or socket #)
manifest: gets
manifest: get bytes
manifest: puts
manifest: put bytes
zerovm: handle (given by syscall)
zerovm: connection (mounting) type (infered from manifest by rule described in doc/channels.txt)

plan:
+ change "manifest_parser.c" "manifest_parser.h". new function to get "Channel" variable length array
+ another new function: parse "value" by given delimiter (use for commandline and channel)
+ manifest_setup. new initializer for system manifest
- main(remove networking) to prefetch/mount_chanel 
- "prefetch.c"/"prefetch.h". move zmq network channels draft
+ preload
--- removed premap
+ mount_chanel.c/mount_chanel.h new channels design
+ trap
+- manifest_keywords. replace everything about channels with the sing new keyword "Channel"

- check std*. all std must be set before nexe start. if not passed by manifest... (fail, do default action?)

ZEROVM API
==========
- zvm.c / zvm.h a new zvm api
- trap.c / trap.h 
? split error codes from zvm.h into 2 parts: internal zerovm and external (for the user)
- rewrite user attributes routines / data

MANIFEST
========
- change manifest version


in the current version:
-------------------------------------------------------------
- add extended signals handling to zerovm. zerovm must survive any nexe error.
	care about zerovm report
	care about channels

- constant zerovm log.
  remove log setup from manifest
  generate log name using define from compiler -D and pid
  create log asap (all zerovm messages goes there)

-+ solve problem with the channels count: how to inform user side, or how to
  give channels descriptors to user side passing given UserManifest object?
  +temporary solution: preallocated array to hold as much as 1024 channels
  another solution: untrusted code will invoke trap setup twice - 1st time to get number of channels
                    and 2nd time to get channels information (space must be provided)
  yet another solution: allocate memory from user space and return user the pointer

- make 5 channel types: stdin (c99), stdout(c99), netin, netout, cdr(random read, append only write)
  ? what for do we need c99 stdin/stdout? stdout(stderr) will be lost after nexe exit. stdin(keyboard)
  just useless, if not redirected stdin is always empty. if redirected, represent r/o data which we
  can emulate via cdr. actually c99 stdin/stdout/stderr can be emulated via cdr
  update: for a user it would be only 3 channel types: input, output and random acces image.
  input stand for stdin and netin; output - stdout, stderr, netout; image - random access storage
  over cdr
  update: make 2 channel types: generic and cdr

- move everything about "NETWORKING" to prefetch if impossible - remove "prefetch"

- all NETWORKING "todo" comments and NETWORKING conditional compilation must be removed
  appropriate changes should be made, of course

- add NodeName to manifest (for networking)
  
- write more strict channels dealocation: free all allocated memory, free nacl descriptor e.t.c


in the next version:
-------------------------------------------------------------
- update validator (remove dfa support)
  decide should we use standalone validator or not?
- add cpu features detection to sort (or even better - to zrt)
- update /readme (use "force" to make the user download nacl sdk zerovm currently uses) 

+- replace COND_ABORT() macro to something more finished and strict:
  any fail cases which must terminate nacl should be logged to nacl log
  any "impossible fail" must be checked by assert() (main purpose: prevent 
  improper zerovm code changes/usage) any non fatal cases must use something else (not "ABORT")
- move trap.c to service_runtime/. even better to move the code inside *syscall*.* and remove
  trap.* files
- put all invocations of manifest initializations to nacl init modules
- make defines (or something else) to hold manifest keywords and use it
  instead of "magic" strings. defines should be put into "manifest_keywords.h"
- move all error messages and codes to nacl_error_code.* (especially from sel_main.c and manifest/)
  note: except fatal errors
  WARNING: get familiar with UMA first. perhaps it is not so good to update its error codes
- make one extra trap() function - set_syscallback(). because using trap() setup for it
  has potentially problem and yet look ugly.
  update: rework trap() api
- gather and classify all internal error codes to one enumeration
  perhaps it would be a good idea to include "src/service_runtime/include/sys/errno.h"
  (and other headers with error/return codes)
-+ make timeout engine instead of useless ResumeCpuClock() and PauseCpuClock()
	update: ResumeCpuClock() and PauseCpuClock() removed
- i need to decide what nacl syscalls will be counted against max_syscall:
  1. all
  2. existing only
  3. trap()
  4. only those who translated to the real system calls -- GOOD CANDIDATE
  5. none


completed releases:
-------------------------------------------------------------
+ remove not nessessary switches from zerovm command line
  only manifest, debug and validator switches must remain
+ completely remove nacl random  
+ "blob" completely removed from the zerovm code
+ check NaCl_page_alloc_randomized() and nap->dispatch_thunk.
  if it is really randomized and user can read it, it should be
  changed. user must not get random values bypassing manifest
  +update: fix thunk. it should be constant. remove randomization


problems to solve in the future versions:
-------------------------------------------------------------
- find the way how to exchange variable length arrays between trusted and untrusted code 
