this document is under construction, don't use it!
полное описание zerovm

оглавление:
- dictionary, bestiary
- установка zerovm, nacl sdk e.t.c.
- начало работы (quick start)
- командная строка zerovm
- отчеты zerovm
- детерминизм

dictionary, bestiary (###)
(нижеследующие термины возможно не совсем соответствуют общепринятым и не совсем точно
описывают то о чем рассказывается в документе. некоторые термины даны на английском языке,
а некоторые - на русском. возможно что-то я пропустил по невнимательности. прошу прощения. 
желающие могут предложить свои варианты, более разумные, ясные и аргументированные)
- zerovm
  это минимальная виртуальная машина для запуска nacl nexe modules
  zerovm не поддерживает большую часть nacl syscalls, вместо этого он использует механизм 
  передачи управления в изолируемый код (syscallback) и позволяет ему сделать всю работу.
  при этом untrusted код может использовать zerovm api для получения обслуживания 
  ввода/вывода, выделения памяти, завершения работы и т.д.
- детерминизм, сильный детерминизм, слабый детерминизм
  (можно взять из determinism.txt)
- zerovm api
  (можно взять из api.txt)
- zrt
  библиотека "времени выполнения" обслуживает nacl syscalls вместо zerovm
  в последнее время смысл zrt немного изменился и включает в себя так же
  nacl модули портированного под zerovm программного обеспечения. рассматривается
  возможность выделения этого "довеска" в самостоятельные проекты.
  если специально не оговаривается, то zrt надо рассматривать как прослойку между
  nacl glibc и zerovm. zrt позволяет компилировать c/c++ программы для zerovm
  без их переделки (достаточно включить "zrt.h" в файл main()) 
- swift
  "облачное хранилище". часть проекта openstack. проектом litestack используется как
  основная часть файловой системы хранилища
- name server
  вспомогательная программа обеспечивающая установление связи между zerovm-ами
- nacl sdk
  инструмены позволяющие разрабатывать программы для google native client (nacl)
- nacl syscall
  системный вызов nacl
- syscallback
  (большую часть текста можно взять из "syscallback.txt")
- trap
  механизм призваный заменить nacl syscalls. занимает 0-е положение в таблице
  системных вызовов (trampoline)
- rdtsc issue
  инструкция rdtsc - часть системы команд i86, возвращает информацию счетчика tsc
  и таким образом позволяет пользовательской программе замерять время выполнения
  собственного кода, что нарушает детерминизм. найдено временное решение: сделана
  заплатка в валидаторе nacl, инструкция объявлена недопустимой, сделана заплатка
  в nacl_stubout и инструкция заменяется nop (no operation)
- квантовые источники
  источник квантовых данных. допустим в "слабой модели" детерминизма. не допускает
  "воспроизведения", другими словами невозможно воссоздать условия при которых источник
  будет выдавать те же данные, что и в предыдущую сессию. например, /dev/urandom 
- квантовые данные
  невоспроизводимые данные из квантового источника
- каналы
  (описание пользовательских каналов. и описание их реализации на стороне zerovm.
  ошибки каналов, типы и т.д. большую часть можно взять из документа "channels.txt")
- запутанный канал
  каналы по которым передаются одни и те же данные из разных источников объединены в
  один условный канал, который может контролировать правильность передаваемых данных
  (при количестве каналов более 1) и восстанавливать данные (при количестве каналов 
  более 2). упрощенно алгоритм действия запутанного канала можно описать следующим 
  образом:
  1. при поступлении очередной порции данных от всех каналов составляющих запутанный
     канал, данные сравниваются между собой (ниже будет описан случай данных разного 
     размера) если есть хотя бы 2 канала с одинаковыми данными, данные считаются верными
     и используются, а каналы передавшие неверные данные отключаются. т.о. можно 
     запускать кластер на потенциально сбойном оборудовании
  2. для ускорения работы кластера можно не дожидаться данных из остальных источников 
     запутанного канала, если уже есть 2 канала приславшие совпадающие данные
  
  пока что предполагается, что размер пакета данных в запутанном канале всегда одинаков
  для всех составляющих его каналов. однако, можно легко убрать это ограничение если
  отсылать "отвалидированные" данные в том количестве в котором они уже есть
  
- пользовательская сессия
  все действия выполненные пользовательской программой от начала ее работы до конца. 
- модуль nacl (nexe, пользовательский код)
  модуль построенный в соответствиями с требованиями nacl и запускаемый или под управлением
  sel_ldr из nacl, или zerovm 
- доверенный код
  код проекта не предназначенный для выполнения под управлением zerovm
- опекаемый код (изолируемый код, untrusted side)
  код исполняемый под управлением zerovm 
- трамплин (батут, таблица прерываний)
  опекаемый код. занимает 64kb, начиная с адреса 0x10000 в пространстве пользователя.
  содержит адреса всех системных вызовов nacl и trap 
- пользовательское пространство (пользовательская адресация)
  32-битное пространство являющееся частью 64-битного пространства zerovm. занимает 4gb
  (не все пользовательское пространство доступно пользователю). содержит трамплин,
  пользовательский код и данные, пользовательскую кучу и стек. также к пользовательскому 
  пространству можно отнести 2 бампера предотвращающих выход за пределы 
  пользовательского пространства. бамперы недоступны пользователю и занимают 40gb + 64kb и 40gb
- пользовательская куча
  доступная на чтение и запись область из пространства пользователя, расположенная до стека.
  размер кучи определяется манифестом сессии
- пользовательский стек
  стек расположенный в пространстве пользователя (в самом конце пространства). занимает 16gb
- манифест (системный манифест)
  (часть текста можно взять из "manifest.txt")
- манифест (пользовательский манифест)
  (часть текста можно взять из "api.txt")
- кластер
  один или больше zerovm-ов работающих одновременно и связанных каналами
  при этом совокупность этих каналов представляют собой связный направленный граф
- однородные аппаратные средства
  компьютеры имеющие процессоры с одинаковой системой команд одинаково работающих
  на одинаковых данных. (если процессоры, например, возращают разные значения при
  вызове cpuid, то они не считаются одинаковыми). однако если программа не 
  использует различающиеся возможности процессоров, то компьютеры поддерживающие
  только требуемое программой подмножество инструкций, можно считать условно
  однородными.
- пользовательское окружение
  переменные окружения доступные пользователю через trap или через соответствующий
  параметр main(int argc, char **argv, char **envp) - envp. пользовательское окружение
  задается манифестом
- пользовательская командная строка
  задается манифестом. доступна через параметры main()
- имя узла
  argv[0] (см. "пользовательская командная строка"). задается манифестом.
- etag
  механизм контроля целостности данных. используется для данных передаваемых по каналам,
  пользовательской памяти. сейчас в качестве функции подсчета контрольных сумм
  применяется sha1. каждый канал связи завершается спецсимволом zvm_eof, 
  включающим в себя контрольную сумму (control tag, tag), что позволяет
  обнаруживать порчу данных при передаче

установка zerovm, nacl sdk e.t.c.
(пока что эта часть не готова, часть информации можно получить из README,
остальное будет добавлено позднее при участии группы litestack ops)

начало работы (quick start)
(в этой главе описывается создание приложения для выполнения под управлением zerovm)

командная строка zerovm
(описание ключей запуска zerovm и примеры использования) 

отчеты zerovm
(описание кодов возврата, report, syslog, поведение zerovm в случае
возникновения неисправимой ошибки (signal) в (un)trusted коде)

детерминизм
(todo: переместить в бестиарий)
  zerovm реализует "слабую модель детерминизма", которая в отличие от "сильной" 
  позволяет использовать через обычные каналы квантовые источники данных (будет 
  описано позднее) и не работает на неоднородном аппаратном обеспечении. есть и 
  еще несколько ограничений, но не принципиальных, а технических, связаных с 
  использованием сторонних библиотек. после решения всех проблем планируется
  реализация "сильной модели детерминизма" (вообще, введение двух "детерминизмов"
  с громоздким описанием их отличий, вместо простого и ясного детерминизма,
  возникло из-за разногласий в команде о том, что считать детерминизмом)

  условия детерминизма (слабого):
  - пользовательская сессия (nexe run time) должна завершиться успешно
    (имеется ввиду отсутствие прерывания исполнения в результате возникновения
    сигнала в доверенном или опекаемом коде)
  - сессия должна выполняться на однородном "железе"
    (все компьютеры должны иметь одинаковые процессоры. под "одинаковыми" имеются
    ввиду процессоры одинаково обрабатывающие одинаковые данные. например, два
    процессора интел выдающие разную информацию по cpuid не будут считаться одинаковыми)
  - не должны использоваться "квантовые источники" данных
    (например, подключение /dev/urandom к пользовательской программе сломает детерминизм.
    правильным рещением будет использование специальной сессии zerovm, которая запишет
    необходимое количество данных из /dev/urandom в файл, а затем другая сессия 
    воспользуется уже сохраненными данными. вообще, "квантовые" данные легко превратить
    в обычные "фиксацией" и это можно делать параллельно с их обработкой)
  - должен использоваться механизм контроля данных - etag. в случае обнаружения ошибки в
    канале вся сессия должна быть рестартована. так же должны быть рестартованы и все
    зависимые сессии. в дальнейшем, для этого будут использоваться "запутанные" каналы,
    которые смогут не только обнаруживать порчу данных, но и "исправлять"  их (на самом
    деле, не столько исправлять сколько переключаться на источник выдающий верные данные).
