This document describes syscallback
-----------------------------------

Essentially, syscallback provides the ability to intercept all the syscalls from the
user code. The only syscall that cannot be intercepted is "trap" (which allows
user to exploit zerovm special services when syscallback is installed). 

To intercept a syscall user code must contain a handler (example of such code
can be found in "api/syscall_manager.S" and "api/zrt.c").
When intercepting a syscall the user must take care of the stack and the registers.

More details about the NaCl syscall guts can be found in the Google NaCl documentation.
In a few words the NaCl syscall is a call that has a special format:
stack (contains 64-bit values).
stack[0] == syscall address in trampoline (syscall number can be calculated from this 64-bit value)
stack[1] == return address to the user code that invoked the syscall
arguments for syscalls come inside 32-bit registers:
argument 1 == edi
argument 2 == esi
argument 3 == edx
argument 4 == ecx
argument 5 == r8d
argument 6 == r9d

To set a syscallback the user should call zvm_setup from zerovm api (or use trap()
with TrapUserSetup callback). The user should set the "syscallback" field 
of the UserManifest object to a new handler address (defined in the user code). 
To remove the syscallback the user can use the same procedure, but should set the "syscallback" field to 0.

Note: user program cannot exit as usual (by calling exit) if user already set a syscallback. To perform exit 
user should invoke zvm_exit from zerovm api (or use trap() with TrapExit callback).
Another way, of course, is just to remove the syscallback before exit.
