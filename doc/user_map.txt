This document describes user memory map
(up to date 2014-06-06, needs editing)
WARNING: the ZeroVM code is still under construction, and the document
describes facts "as it should be"
---------------------------------------

the user session can have access to the address space 4gb large. size
of memory available for user specified in manifest by "Memory" key (see
manifest.txt). user address space have some predefined regions:

NULL       -- 0x00000000..0x0000FFFF, system null (protection "none")
TRAMPOLINE -- 0x00010000..0x0001FFFF, "trap" call area (protection "rx")
HEAP       -- 0x00020000..0x????FFFF, user heap (protection "rw")
HOLE       -- 0x????0000..0x????FFFF, "leftovers" of user address space. can
              be 0 if manifest have 4gb in "Memory" switch (protection "none")
MANIFEST   -- 0xFF000000..0xFEFEFFFF, user manifest (protection "r")(usually
              64kb, but can be bigger)
STACK      -- 0xFEFF0000..0xFFFFFFFF, user stack (protection "rw")

NOTE: untrusted code cannot change protection of NULL, TRAMPOLINE and STACK. 
zvm_mprotect() will return -EACCESS (-13) for any attempt to do that.

when ZeroVM calculates the memory amount available for usage it takes in
account all regions mentioned above. so user have ("Memory" - 0x1020000)
bytes, where "Memory" is a value specified by manifest switch of the same name

untrusted code can use free memory at its discretion. however, standard way
to spend free space is:
TEXT      -- 0x00020000..0x????FFFF, user executable (protection "rx")
R/O DATA  -- 0x????0000..0x????FFFF, read only user data (protection "r")
R/W DATA  -- 0x????0000..0x????FFFF, user heap (protection "rw")

update:
ZeroVM 2* (compatible) contains extra region (64kb long) at address 0xFEFF0000.
this region is read only (not locked, protection can be changed). the region
contains compatibility pointer (0xFEFFFFFC) to user manifest

update:
since ZeroVM 2* (compatible) needs user stack and registers set properly uboot
(default untrusted elf loader) use jump instead of z_mprotect() and does not
deallocate own space. zerovm runtime library can deallocate it on its own
initiative, zvmlib can be used as example, see free_uboot(). the procedure is
safe and can be used with both ZeroVM 2* (compatible) and ZeroVM 2